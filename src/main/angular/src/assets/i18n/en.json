{
  "AppComponent.closeMenu": "Close menu",
  "AppComponent.appliances": "Appliances",
  "AppComponent.appliance.new": "New Appliance",
  "AppComponent.control": "Control",
  "AppComponent.forum": "Forum",
  "AppComponent.help": "Help",
  "AppComponent.meter": "Meter",
  "AppComponent.project": "Project",
  "AppComponent.schedules": "Schedules",
  "AppComponent.settings": "Settings",
  "AppComponent.status": "Status",

  "ApplianceComponent.id": "ID",
  "ApplianceComponent.id.tooltip": "Unique appliance ID beginning with 'F-', followed by a 8 digit number identifying your appliance range, followed by '-' and a 12 digit number identifying the appliance, followed by '-00'",
  "ApplianceComponent.general": "General",
  "ApplianceComponent.vendor": "Manufacturer",
  "ApplianceComponent.name": "Name",
  "ApplianceComponent.type": "Type",
  "ApplianceComponent.serial": "Serial number",
  "ApplianceComponent.characteristics": "Characteristics",
  "ApplianceComponent.minPowerConsumption": "Min. power consumption [W]",
  "ApplianceComponent.minPowerConsumption.tooltip": "Provide only for appliances with controllable power consumption (wallboxes, appliances with PWM/levl switch). Any power recommendation will not undercut this value.",
  "ApplianceComponent.maxPowerConsumption": "Max. power consumption [W]",
  "ApplianceComponent.maxPowerConsumption.tooltip": "For appliances without controllable power consumption this is the power consumption on the type label. Devices with controllable power consumption will not receive a power recommendation exceeding this value.",
  "ApplianceComponent.minOnTime": "Min. switch on time [s]",
  "ApplianceComponent.minOnTime.tooltip": "If the appliance will be switched on, it has to be in this state for the specified time.",
  "ApplianceComponent.maxOnTime": "Max. switch on time [s]",
  "ApplianceComponent.maxOnTime.tooltip": "If the appliance will be switched on, it must not be in this state longer than the specified time.",
  "ApplianceComponent.minOffTime": "Min. switch off time [s]",
  "ApplianceComponent.minOffTime.tooltip": "If the appliance will be switched off, it has to be in this state for the specified time.",
  "ApplianceComponent.maxOffTime": "Max. switch off time [s]",
  "ApplianceComponent.maxOffTime.tooltip": "If the appliance will be switched off, it must not be in this state longer than the specified time.",
  "ApplianceComponent.interruptionsAllowed": "Interruptions allowed",
  "ApplianceComponent.interruptionsAllowed.tooltip": "Allow handling of unpredictable energy demands of other appliances or bad weather conditions.",
  "ApplianceComponent.type.AirConditioning": "Air Conditioning",
  "ApplianceComponent.type.Charger": "Charger",
  "ApplianceComponent.type.DishWasher": "Dish Washer",
  "ApplianceComponent.type.Dryer": "Dryer",
  "ApplianceComponent.type.ElectricVehicle": "Electric Vehicle",
  "ApplianceComponent.type.EVCharger": "Wallbox",
  "ApplianceComponent.type.Freezer": "Freezer",
  "ApplianceComponent.type.Fridge": "Fridge",
  "ApplianceComponent.type.Heater": "Heater",
  "ApplianceComponent.type.HeatPump": "HeatPump",
  "ApplianceComponent.type.Motor": "Motor",
  "ApplianceComponent.type.Pump": "Pump",
  "ApplianceComponent.type.WashingMachine": "Washing Machine",
  "ApplianceComponent.type.Other": "Other",
  "ApplianceComponent.notification.heading": "Notifications",
  "ApplianceComponent.notification.senderId": "Sender ID for notifications",
  "ApplianceComponent.error.id_pattern": "This ID had to match the following scheme - only digits may be changed:\nF-00000001-000000000001-00",
  "ApplianceComponent.error.id_custom": "This ID is already used by another appliance",
  "ApplianceComponent.error.minPowerConsumption_pattern": "The minimal power consumption has to be a number",
  "ApplianceComponent.error.maxPowerConsumption_pattern": "The maximum power consumption has to be a number",
  "ApplianceComponent.error.minOnTime_pattern": "The minimal on time has to be a number",
  "ApplianceComponent.error.maxOnTime_pattern": "The maximum on time has to be a number",
  "ApplianceComponent.error.minOffTime_pattern": "The minimal off time has to a number",
  "ApplianceComponent.error.maxOffTime_pattern": "The maximum off time has to a number",
  "ApplianceComponent.confirmDeletion": "Are you sure?",

  "FilenameInputComponent.error.missing": "The file does not exist.",
  "FilenameInputComponent.error.not-readable": "The file is not readable.",
  "FilenameInputComponent.error.not-writable": "The file is not writeable.",
  "FilenameInputComponent.error.not-executable": "The file is not executable.",

  "MeterComponent.type": "Type",
  "MeterComponent.isMasterMeter": "Master meter",
  "de.avanux.smartapplianceenabler.meter.S0ElectricityMeter": "S0",
  "de.avanux.smartapplianceenabler.meter.ModbusElectricityMeter": "Modbus",
  "de.avanux.smartapplianceenabler.meter.MqttElectricityMeter": "MQTT",
  "de.avanux.smartapplianceenabler.meter.HttpElectricityMeter": "HTTP",
  "de.avanux.smartapplianceenabler.meter.SlaveElectricityMeter": "Slave meter",

  "MeterS0Component.gpio": "GPIO",
  "MeterS0Component.pinPullResistance": "Internal resistor",
  "MeterS0Component.pinPullResistance.PULL_DOWN": "Pull down",
  "MeterS0Component.pinPullResistance.PULL_UP": "Pull up",
  "MeterS0Component.impulsesPerKwh": "Pulses/kWh",
  "MeterS0Component.minPulseDuration": "Minimal pulse duration [ms]",
  "MeterS0Component.error.gpio_pattern": "GPIO has to be a number",
  "MeterS0Component.error.impulsesPerKwh_pattern": "The number of pulses/kWh has to be a number",
  "MeterS0Component.error.minPulseDuration_pattern": "The minimal pulse duration has to be a number",

  "MeterModbusComponent.idref": "Modbus",
  "MeterModbusComponent.slaveAddress": "Slave address",
  "MeterModbusComponent.pollInterval": "Poll interval [s]",
  "MeterModbusComponent.Power": "Power",
  "MeterModbusComponent.Energy": "Meter reading",
  "MeterModbusComponent.button.addModbusRead": "Add register",
  "MeterModbusComponent.error.slaveAddress_pattern": "The slave address has to be a number",
  "MeterModbusComponent.error.factorToValue_pattern": "The factor-to-value has to be a (float) number",
  "MeterModbusComponent.error.pollInterval_pattern": "The poll interval has to be a number",

  "MeterMqttComponent.topic": "Topic",
  "MeterMqttComponent.name": "Parameter",
  "MeterMqttComponent.Power": "Power",
  "MeterMqttComponent.Energy": "Meter reading",
  "MeterMqttComponent.contentProtocol": "Format",
  "MeterMqttComponent.path": "Value extraction path",
  "MeterMqttComponent.timePath": "Time extraction path",
  "MeterMqttComponent.extractionRegex": "Extraction regex",
  "MeterMqttComponent.factorToValue": "Factor to value",
  "MeterMqttComponent.error.factorToValue_pattern": "The factor-to-value has to be a (float) number",

  "MeterHttpComponent.pollInterval": "Poll interval [s]",
  "MeterHttpComponent.contentProtocol": "Format",
  "MeterHttpComponent.Power": "Power",
  "MeterHttpComponent.Energy": "Meter reading",
  "MeterHttpComponent.button.addHttpRead": "Add URL",
  "MeterHttpComponent.error.pollInterval_pattern": "The poll interval has to be a number",

  "MeterMasterComponent.meterMaster": "Master meter",
  "MeterMasterComponent.hint": "If master control or/and slave control have the configured state the power consumption of this meter is assigned to the slave.",
  "MeterMasterComponent.masterSwitchOn": "Master control",
  "MeterMasterComponent.slaveSwitchOn": "Slave control",
  "MeterMasterComponent.switchOn.true": "has to be switched on",
  "MeterMasterComponent.switchOn.false": "has to be switched off",
  "MeterMasterComponent.error.masterSwitchOn_custom": "Master control oder slave control has to be configured",
  "MeterMasterComponent.error.slaveSwitchOn_custom": "Master control oder slave control has to be configured",

  "MeterSlaveComponent.masterMeterApplianceName": "Master meter",

  "HeaderComponent.title": "Smart Appliance Enabler",
  "HeaderComponent.newVersionAvailable": "Version {{version}} available",

  "HttpReadComponent.url": "URL",
  "HttpReadComponent.contentType": "Content type",
  "HttpReadComponent.username": "Username",
  "HttpReadComponent.password": "Password",
  "HttpReadComponent.button.remove": "Remove URL",
  "HttpReadComponent.button.addValue": "Add parameter",
  "HttpReadComponent.button.removeValue": "Remove parameter",
  "HttpReadComponent.error.url_pattern": "The URL has to be valid",

  "HttpReadValueComponent.name": "Parameter",
  "HttpReadValueComponent.method": "Method",
  "HttpReadValueComponent.data": "Data",
  "HttpReadValueComponent.path": "Extraction path",
  "HttpReadValueComponent.extractionRegex": "Extraction regex",
  "HttpReadValueComponent.factorToValue": "Factor to value",
  "HttpReadValueComponent.error.factorToValue_pattern": "The factor-to-value has to be a (float) number",

  "HttpWriteComponent.url": "URL",
  "HttpWriteComponent.contentType": "Content type",
  "HttpWriteComponent.username": "Username",
  "HttpWriteComponent.password": "Password",
  "HttpWriteComponent.button.remove": "Remove URL",
  "HttpWriteComponent.button.addValue": "Add parameter/action",
  "HttpWriteComponent.button.removeValue": "Remove parameter",
  "HttpWriteComponent.error.url_pattern": "The URL has to be valid",

  "HttpWriteValueComponent.enabled": "Enabled",
  "HttpWriteValueComponent.name": "Parameter / Action",
  "HttpWriteValueComponent.method": "Method",
  "HttpWriteValueComponent.value": "Value",
  "HttpWriteValueComponent.factorToValue": "Factor to value",
  "HttpWriteValueComponent.error.factorToValue_pattern": "The factor-to-value has to be a (float) number",

  "ControlComponent.type": "Type",
  "de.avanux.smartapplianceenabler.control.AlwaysOnSwitch": "Always switched on",
  "de.avanux.smartapplianceenabler.control.HttpSwitch": "HTTP",
  "de.avanux.smartapplianceenabler.control.LevelSwitch": "Level switch",
  "de.avanux.smartapplianceenabler.control.MeterReportingSwitch": "Meter based state detector",
  "de.avanux.smartapplianceenabler.control.MockSwitch": "Mock switch",
  "de.avanux.smartapplianceenabler.control.ModbusSwitch": "Modbus",
  "de.avanux.smartapplianceenabler.control.MqttSwitch": "MQTT",
  "de.avanux.smartapplianceenabler.control.PwmSwitch": "PWM",
  "de.avanux.smartapplianceenabler.control.Switch": "GPIO",

  "ControlStartingcurrentComponent.startingCurrentDetection": "Starting current detection",
  "ControlStartingcurrentComponent.powerThreshold": "Power threshold [W]",
  "ControlStartingcurrentComponent.powerThreshold.tooltip": "During starting current detection the power has to stay above this value. During finish current detection the power has to remain below this value.",
  "ControlStartingcurrentComponent.startingCurrentDetectionDuration": "Duration of transgression during switch on [s]",
  "ControlStartingcurrentComponent.startingCurrentDetectionDuration.tooltip": "For this duration the power has to stay above the power threshold in order to being evaluated as starting current",
  "ControlStartingcurrentComponent.finishedCurrentDetectionDuration": "Duration of undershoot during switch off [s]",
  "ControlStartingcurrentComponent.finishedCurrentDetectionDuration.tooltip": "For this duration the power has to stay below the power threshold in order to being evaluated as finish current",
  "ControlStartingcurrentComponent.minRunningTime": "Min. runtime [s]",
  "ControlStartingcurrentComponent.minRunningTime.tooltip": "Finish current detection only starts after the minimum runtime, which starts with the starting current being detected",
  "ControlStartingcurrentComponent.error.powerThreshold_pattern": "The power threshold has to be a number",
  "ControlStartingcurrentComponent.error.startingCurrentDetectionDuration_pattern": "The duration of transgression during switch on has to be a number",
  "ControlStartingcurrentComponent.error.finishedCurrentDetectionDuration_pattern": "The duration of undershoot during switch off has to be a number",
  "ControlStartingcurrentComponent.error.minRunningTime_pattern": "The minimal runtime has to be a number",

  "ControlSwitchOptionComponent.switchOption": "Switch-On option",
  "ControlSwitchOptionComponent.powerThreshold": "Power threshold [W]",
  "ControlSwitchOptionComponent.powerThreshold.tooltip": "During switch-on detection the power has to stay above this value. During switch-off detection the power has to remain below this value.",
  "ControlSwitchOptionComponent.switchOnDetectionDuration": "Switch-on detection duration [s]",
  "ControlSwitchOptionComponent.switchOnDetectionDuration.tooltip": "For this duration the power has to stay above the power threshold in order to being evaluated as switch-on",
  "ControlSwitchOptionComponent.switchOffDetectionDuration": "Switch-off detection duration [s]",
  "ControlSwitchOptionComponent.switchOffDetectionDuration.tooltip": "For this duration the power has to stay below the power threshold in order to being evaluated as switch-off",
  "ControlSwitchOptionComponent.error.powerThreshold_pattern": "The power threshold has to be a number",
  "ControlSwitchOptionComponent.error.switchOnDetectionDuration_pattern": "The duration of transgression during switch on has to be a number",
  "ControlSwitchOptionComponent.error.switchOffDetectionDuration_pattern": "The duration of undershoot during switch off has to be a number",

  "ControlMeterreportingComponent.powerThreshold": "Power threshold [W]",
  "ControlMeterreportingComponent.offDetectionDelay": "Switch off delay [s]",
  "ControlMeterreportingComponent.offDetectionDelay.tooltip": "For this duration the power has to stay below the power threshold in order to being evaluated as switch off",
  "ControlMeterreportingComponent.error.powerThreshold_pattern": "The power threshold has to be a number",
  "ControlMeterreportingComponent.error.offDetectionDelay_pattern": "The switch off delay has to be a number",

  "ControlSwitchComponent.gpio": "GPIO",
  "ControlSwitchComponent.reverseStates": "GPIO state inverse",
  "ControlSwitchComponent.error.gpio_pattern": "GPIO has to be a number",

  "ControlHttpComponent.On": "Switch on",
  "ControlHttpComponent.Off": "Switch off",
  "ControlHttpComponent.read.On": "Switched on",
  "ControlHttpComponent.readControlState": "Read control state using HTTP",
  "ControlHttpComponent.button.addHttpWrite": "Add URL",

  "ControlModbusComponent.On": "Switch on",
  "ControlModbusComponent.Off": "Switch off",
  "ControlModbusComponent.idref": "Modbus",
  "ControlModbusComponent.slaveAddress": "Slave address",
  "ControlModbusComponent.button.addModbusWrite": "Add register",
  "ControlModbusComponent.error.slaveAddress_pattern": "The slave address has to be a number",

  "ControlMqttComponent.topic": "Topic",
  "ControlMqttComponent.onPayload": "Payload for switch-on",
  "ControlMqttComponent.offPayload": "Payload for switch-off",
  "ControlMqttComponent.statusTopic": "State topic",
  "ControlMqttComponent.statusExtractionRegex": "Regex for state extraction",

  "ControlLevelComponent.type": "Real type",
  "ControlLevelComponent.control.heading": "Control",
  "ControlLevelComponent.button.addControl": "Add control",
  "ControlLevelComponent.button.removeControl": "Delete control",
  "ControlLevelComponent.powerlevels.heading": "Power levels",
  "ControlLevelComponent.powerlevels.power": "Power [W]",

  "ControlPwmComponent.gpio": "GPIO",
  "ControlPwmComponent.pwmFrequency": "PWM frequency [Hz]",
  "ControlPwmComponent.minDutyCycle": "Min. duty cycle [%]",
  "ControlPwmComponent.minDutyCycle.tooltip": "Minimal duty cycle (ration of pulse duration to total period) expressing minimal power consumption.",
  "ControlPwmComponent.maxDutyCycle": "Max. duty cycle [%]",
  "ControlPwmComponent.maxDutyCycle.tooltip": "Maximum duty cycle (ration of pulse duration to total period) expressing maximum power consumption.",
  "ControlPwmComponent.error.gpio_pattern": "GPIO has to be a number",
  "ControlPwmComponent.error.pwmFrequency_pattern": "PWM frequency has to be a number",
  "ControlPwmComponent.error.minDutyCycle_pattern": "Duty cycle has to be a number",
  "ControlPwmComponent.error.maxDutyCycle_pattern": "Duty cycle has to be a number",

  "ControlEvchargerComponent.heading": "Wallbox",
  "ControlEvchargerComponent.template": "Template",
  "ControlEvchargerComponent.template.placeholder": "choose from existing wallbox configurations",
  "ControlEvchargerComponent.protocol": "Protocol",
  "ControlEvchargerComponent.protocol.placeholder": "choose for manual configuration",
  "ControlEvchargerComponent.protocol.HTTP": "HTTP",
  "ControlEvchargerComponent.protocol.MODBUS": "Modbus",
  "ControlEvchargerComponent.voltage": "Voltage [V]",
  "ControlEvchargerComponent.error.voltage_pattern": "The voltage has to be a number",
  "ControlEvchargerComponent.phases": "Phases",
  "ControlEvchargerComponent.error.phases_pattern": "Phases has to be a number",
  "ControlEvchargerComponent.pollInterval": "Poll interval [s]",
  "ControlEvchargerComponent.error.pollInterval_pattern": "The poll interval has to be a number",
  "ControlEvchargerComponent.startChargingStateDetectionDelay": "Start state detection delay [s]",
  "ControlEvchargerComponent.error.startChargingStateDetectionDelay_pattern": "The start state detection delay has to be a number",
  "ControlEvchargerComponent.startChargingStateDetectionDelay.tooltip": "After switch on/off the charging state will not be polled for the specified duration in order to give the charger time to establish the requested state",
  "ControlEvchargerComponent.chargePowerRepetition": "Charge current repetition [s]",
  "ControlEvchargerComponent.error.chargePowerRepetition_pattern": "The charge current repetition has to be number",
  "ControlEvchargerComponent.chargePowerRepetition.tooltip": "If the charger requires to set the charge power periodically the amount of seconds should be entered here.",
  "ControlEvchargerComponent.forceInitialCharging": "Force initial charging",
  "ControlEvchargerComponent.forceInitialCharging.tooltip": "After a vehicle has been connected the charger will be switched on immediately until the charger reports state 'charging'. Then the charger will be stopped until a switch on recommendation is received. Required for some EVs like Renault Zoe!",
  "ControlEvchargerComponent.latitude": "Latitude",
  "ControlEvchargerComponent.latitude.tooltip": "Used to identify the vehicle connected to the wallbox if there are multiple vehicles",
  "ControlEvchargerComponent.error.latitude_pattern": "Latitude has to be a number",
  "ControlEvchargerComponent.longitude": "Longitude",
  "ControlEvchargerComponent.longitude.tooltip": "Used to identify the vehicle connected to the wallbox if there are multiple vehicles",
  "ControlEvchargerComponent.error.longitude_pattern": "Longitude has to be a number",
  "ControlEvchargerComponent.name": "Parameter / Action",
  "ControlEvchargerComponent.registerAddress": "Register address",
  "ControlEvchargerComponent.write": "Write access",
  "ControlEvchargerComponent.registerType": "Register type",
  "ControlEvchargerComponent.words": "Words",
  "ControlEvchargerComponent.byteOrder": "Byte order",
  "ControlEvchargerComponent.extractionRegex": "Extraction regex",
  "ControlEvchargerComponent.value": "Value",
  "ControlEvchargerComponent.factorToValue": "Factor to value",
  "ControlEvchargerComponent.VehicleNotConnected": "Vehicle not connected",
  "ControlEvchargerComponent.VehicleConnected": "Vehicle connected",
  "ControlEvchargerComponent.Charging": "Charging",
  "ControlEvchargerComponent.StartCharging": "Start charging",
  "ControlEvchargerComponent.StopCharging": "Stop charging",
  "ControlEvchargerComponent.Error": "Charger reports error",
  "ControlEvchargerComponent.ChargingCurrent": "Set charging current",
  "ControlEvchargerComponent.headingEv": "Vehicles",
  "ControlEvchargerComponent.button.addElectricVehicle": "Add Vehicle",
  "ControlEvchargerComponent.message.missingRead": "Read access for the following parameters has not yet been configured",
  "ControlEvchargerComponent.message.missingWrite": "Write access for the following parameters/actions has not yet been configured",

  "ControlEvchargerModbusComponent.idref": "Modbus",
  "ControlEvchargerModbusComponent.idref.tooltip": "Selection of Modbus/TCP configured in \"Settings\"",
  "ControlEvchargerModbusComponent.slaveAddress": "Slave address",
  "ControlEvchargerModbusComponent.heading.modbusRead": "Read access",
  "ControlEvchargerModbusComponent.heading.modbusWrite": "Write access",
  "ControlEvchargerModbusComponent.button.addModbusRead": "Add register",
  "ControlEvchargerModbusComponent.button.addModbusWrite": "Add register",
  "ControlEvchargerModbusComponent.error.slaveAddress_pattern": "The slave address has to be a number",

  "ControlEvchargerHttpComponent.contentProtocol": "Format",
  "ControlEvchargerHttpComponent.heading.httpRead": "Read access",
  "ControlEvchargerHttpComponent.heading.httpWrite": "Write access",
  "ControlEvchargerHttpComponent.button.addHttpRead": "Add URL",
  "ControlEvchargerHttpComponent.button.addHttpWrite": "Add URL",

  "ElectricVehicleComponent.name": "Vendor / Model",
  "ElectricVehicleComponent.general": "General",
  "ElectricVehicleComponent.batteryCapacity": "Battery capacity [Wh]",
  "ElectricVehicleComponent.phases": "Phases",
  "ElectricVehicleComponent.maxChargePower": "Max. charge power [W]",
  "ElectricVehicleComponent.chargeLoss": "Charge loss [%]",
  "ElectricVehicleComponent.soc": "Default values for target SOC",
  "ElectricVehicleComponent.defaultSocManual": "Manual [%]",
  "ElectricVehicleComponent.defaultSocOptionalEnergy": "Excess energy [%]",
  "ElectricVehicleComponent.script.heading": "Script to retrieve SOC",
  "ElectricVehicleComponent.script.filename": "Fully qualified filename",
  "ElectricVehicleComponent.script.timeoutSeconds": "Timeout [s]",
  "ElectricVehicleComponent.script.extractionRegex": "SOC extraction regex",
  "ElectricVehicleComponent.script.extractionRegex.tooltip": "This regular expression extracts the SOC as capture group 1. Example: .*state_of_charge': '(\\d+)",
  "ElectricVehicleComponent.script.pluginStatusExtractionRegex": "Plugin state match regex",
  "ElectricVehicleComponent.script.pluginStatusExtractionRegex.tooltip": "This regular expression matches the plugin state as capture group 1. Example: .*PluginState': '(CONNECTED).*",
  "ElectricVehicleComponent.script.pluginTimeExtractionRegex": "Plugin time extraction regex",
  "ElectricVehicleComponent.script.pluginTimeExtractionRegex.tooltip": "This regular expression extracts the time the wallbox cable has been plugged into the car as capture group 1. Example: .*PluginDate': '[0-9/]+ ([0-9:]+).*",
  "ElectricVehicleComponent.script.latitudeExtractionRegex": "Latitude extraction regex",
  "ElectricVehicleComponent.script.latitudeExtractionRegex.tooltip": "This regular expression extracts the latitude of the vehicle as capture group 1. Beispiel: .*Latitude': '([0-9.]+).*",
  "ElectricVehicleComponent.script.longitudeExtractionRegex": "Longitude extraction regex",
  "ElectricVehicleComponent.script.longitudeExtractionRegex.tooltip": "This regular expression extracts the longitude of the vehicle as capture group 1. Beispiel: .*Longitude': '([0-9.]+).*",
  "ElectricVehicleComponent.script.update.heading": "Repeat execution",
  "ElectricVehicleComponent.script.update.afterIncrease": "after SOC change [%]",
  "ElectricVehicleComponent.script.update.afterIncrease.tooltip": "Execution is repeated after the calculated SOC has changed by the specified percentage",
  "ElectricVehicleComponent.script.update.afterSeconds": "after time [HH:MM]",
  "ElectricVehicleComponent.script.update.afterSeconds.tooltip": "Execution is repeated if the specified time has passed since the last execution",
  "ElectricVehicleComponent.error.batteryCapacity_pattern": "The battery capacity has to be a number",
  "ElectricVehicleComponent.error.phases_pattern": "Phases has to be a number",
  "ElectricVehicleComponent.error.maxChargePower_pattern": "The maximum charge power has to be a number",
  "ElectricVehicleComponent.error.chargeLoss_pattern": "Charge loss has to be a percentage",
  "ElectricVehicleComponent.error.defaultSocManual_pattern": "SOC has to be a percentage",
  "ElectricVehicleComponent.error.defaultSocOptionalEnergy_pattern": "SOC has to be a percentage",
  "ElectricVehicleComponent.error.scriptUpdateSocAfterIncrease_pattern": "SOC has to be a percentage",
  "ElectricVehicleComponent.error.scriptUpdateSocAfterTime_pattern": "Time has to be specified as 'Hours:Minutes'",
  "ElectricVehicleComponent.error.scriptTimeoutSeconds_pattern": "Timeout has to be specified in seconds",

  "ModbusReadComponent.address": "Register address",
  "ModbusReadComponent.type": "Register type",
  "ModbusReadComponent.type.Coil": "Coil (FC=1)",
  "ModbusReadComponent.type.Discrete": "Discrete (FC=2)",
  "ModbusReadComponent.type.Holding": "Holding (FC=3)",
  "ModbusReadComponent.type.Input": "Input (FC=4)",
  "ModbusReadComponent.valueType": "Value type",
  "ModbusReadComponent.valueType.Float": "Float",
  "ModbusReadComponent.valueType.Float64": "Float (64bit)",
  "ModbusReadComponent.valueType.Integer": "Integer",
  "ModbusReadComponent.valueType.Integer32": "Integer (32bit)",
  "ModbusReadComponent.valueType.Integer2Float": "Integer as Float",
  "ModbusReadComponent.valueType.String": "String",
  "ModbusReadComponent.words": "Words",
  "ModbusReadComponent.byteOrder": "Byte order",
  "ModbusReadComponent.byteOrder.BigEndian": "Big Endian (Default)",
  "ModbusReadComponent.byteOrder.LittleEndian": "Little Endian",
  "ModbusReadComponent.factorToValue": "Factor to value",
  "ModbusReadComponent.button.addValue": "Add parameter",
  "ModbusReadComponent.button.removeValue": "Remove parameter",
  "ModbusReadComponent.button.remove": "Remove register",
  "ModbusReadComponent.error.address_pattern": "The register address has to be specified as decimal number (e.g. 13) or hexadecimal number (e.g. 0x0A)",
  "ModbusReadComponent.error.bytes_pattern": "The number of bytes has to be a number",
  "ModbusReadComponent.error.factorToValue_pattern": "The factor-to-value has to be a (float) number",

  "ModbusReadValueComponent.name": "Parameter",
  "ModbusReadValueComponent.extractionRegex": "Extraction regex",

  "ModbusWriteComponent.address": "Register address",
  "ModbusWriteComponent.type": "Register type",
  "ModbusWriteComponent.type.Coil": "Coil (FC=5)",
  "ModbusWriteComponent.type.Holding": "Holding (FC=6/16)",
  "ModbusWriteComponent.factorToValue": "Factor to value",
  "ModbusWriteComponent.button.addValue": "Add parameter",
  "ModbusWriteComponent.button.removeValue": "Remove parameter",
  "ModbusWriteComponent.button.remove": "Remove register",
  "ModbusWriteComponent.error.factorToValue_pattern": "The factor-to-value has to be a (float) number",

  "ModbusWriteValueComponent.name": "Parameter / Action",
  "ModbusWriteValueComponent.value": "Value",

  "NotificationComponent.heading": "Notifications",
  "NotificationComponent.enabled": "Enabled",
  "NotificationComponent.types": "Events",
  "NotificationComponent.type.placeholder": "all",
  "NotificationComponent.type.CONTROL_ON": "Switch on",
  "NotificationComponent.type.CONTROL_OFF": "Switch off",
  "NotificationComponent.type.EVCHARGER_VEHICLE_NOT_CONNECTED": "Vehicle not connected",
  "NotificationComponent.type.EVCHARGER_VEHICLE_CONNECTED": "Vehicle connected",
  "NotificationComponent.type.EVCHARGER_CHARGING": "Charging",
  "NotificationComponent.type.EVCHARGER_CHARGING_COMPLETED": "Charging completed",
  "NotificationComponent.type.EVCHARGER_ERROR": "Charger reports error",
  "NotificationComponent.type.COMMUNICATION_ERROR": "Communication error",

  "SchedulesComponent.title": "Schedules",
  "SchedulesComponent.button.addSchedule": "Add schedule",
  "SchedulesComponent.message.notControllable": "Schedules are only available for appliances with a control of a type which can be controlled.",

  "ScheduleComponent.schedule": "Schedule",
  "ScheduleComponent.enabled": "enabled",

  "ScheduleComponent.timeframeType": "Timeframe",
  "de.avanux.smartapplianceenabler.schedule.DayTimeframe": "Day",
  "de.avanux.smartapplianceenabler.schedule.ConsecutiveDaysTimeframe": "Consecutive days",

  "ScheduleComponent.requestType": "Request type",
  "de.avanux.smartapplianceenabler.schedule.RuntimeRequest": "Runtime",
  "de.avanux.smartapplianceenabler.schedule.EnergyRequest": "Energy",
  "de.avanux.smartapplianceenabler.schedule.SocRequest": "Target SOC",

  "ScheduleTimeframeDayComponent.startTime": "Start time [HH:MM]",
  "ScheduleTimeframeDayComponent.endTime": "End time [HH:MM]",
  "ScheduleTimeframeDayComponent.daysOfWeekValues": "Day of week/holiday(s)",
  "ScheduleTimeframeDayComponent.daysOfWeekValues_placeholder": "all",
  "ScheduleTimeframeDayComponent.error.startTime_pattern": "The start time has to be specified as 'Hours:Minutes'",
  "ScheduleTimeframeDayComponent.error.endTime_pattern": "The end time has to be specified as 'Hours:Minutes'",

  "ScheduleTimeframeConsecutivedaysComponent.startDayOfWeek": "From",
  "ScheduleTimeframeConsecutivedaysComponent.startTime": "[HH:MM]",
  "ScheduleTimeframeConsecutivedaysComponent.endDayOfWeek": "To",
  "ScheduleTimeframeConsecutivedaysComponent.endTime": "[HH:MM]",
  "ScheduleTimeframeConsecutivedaysComponent.minRunningTime": "Min. runtime [HH:MM]",
  "ScheduleTimeframeConsecutivedaysComponent.maxRunningTime": "Max. runtime [HH:MM]",
  "ScheduleTimeframeConsecutivedaysComponent.error.startTime_pattern": "The start time has to be specified as 'Hours:Minutes'",
  "ScheduleTimeframeConsecutivedaysComponent.error.endTime_pattern": "The end time has to be specified as 'Hours:Minutes'",

  "ScheduleRequestRuntimeComponent.enabled": "enabled externally",
  "ScheduleRequestRuntimeComponent.minRuntime": "Min. runtime [HH:MM]",
  "ScheduleRequestRuntimeComponent.minRuntime.tooltip": "If a minimal runtime is configured this runtime will be guaranteed. It may be extended up to the maximum runtime if excess energy is available. If a value of 0:00 is configured the appliance will only run if excess energy is available.",
  "ScheduleRequestRuntimeComponent.maxRuntime": "Max. runtime [HH:MM]",
  "ScheduleRequestRuntimeComponent.maxRuntime.tooltip": "The maximum runtime will be guaranteed if no minimal runtime is configured. If a minimal runtime is configured it may be extended up to the maximum runtime if excess energy is available.",
  "ScheduleRequestRuntimeComponent.error.minRuntime_pattern": "The minimal runtime has to be specified as 'Hours:Minutes'",
  "ScheduleRequestRuntimeComponent.error.maxRuntime_pattern": "The maximum runtime has to be specified as 'Hours:Minutes'",

  "ScheduleRequestEnergyComponent.enabled": "enabled externally",
  "ScheduleRequestEnergyComponent.minEnergy": "Min. Energy [Wh]",
  "ScheduleRequestEnergyComponent.minEnergy.tooltip": "If minimal energy is configured this energy will be guaranteed. It may be extended up to the maximum energy if excess energy is available. If a value of 0:00 is configured the appliance will only run if excess energy is available.",
  "ScheduleRequestEnergyComponent.maxEnergy": "Max. Energy [Wh]",
  "ScheduleRequestEnergyComponent.maxEnergy.tooltip": "The maximum energy will be guaranteed if no minimal energy is configured. If a minimal energy is configured it may be extended up to the maximum energy if excess energy is available.",
  "ScheduleRequestEnergyComponent.error.minEnergy_pattern": "The minimal energy has to be specified in Wh",
  "ScheduleRequestEnergyComponent.error.maxEnergy_pattern": "The maximum energy has to be specified in Wh",

  "ScheduleRequestSocComponent.enabled": "enabled externally",
  "ScheduleRequestSocComponent.evId": "Vehicle",
  "ScheduleRequestSocComponent.soc": "Target SOC",
  "ScheduleRequestSocComponent.error.soc_pattern": "SOC has to be a percentage",


  "StatusComponent.title": "Controllable appliances",
  "StatusComponent.message.mqttBrokerNotAvailable": "Currently no MQTT broker is configured or no connection can be established. While this problem persists the Smart Appliance Enabler will not function.",
  "StatusComponent.message.noControllableAppliances": "No controllable appliances",
  "StatusComponent.dashboard.export": "Export Node-RED flows",
  "StatusComponent.dashboard.open": "Open Node-RED dashboard",
  "StatusComponent.exportDialog.title": "Export Node-RED Flow-JSON",
  "StatusComponent.exportDialog.close": "Close",
  "StatusComponent.exportDialog.copyToClipboard": "Copy content to clipboard",
  "StatusComponent.tooltipStopLight": "Click for immediate stop",
  "StatusComponent.tooltipGoLight": "Click for immediate start",
  "StatusComponent.earliestStart": "Earliest start in ",
  "StatusComponent.latestStart": "Latest start in ",
  "StatusComponent.interruptedSince": "Interrupted since ",
  "StatusComponent.runningTime": "Runtime",
  "StatusComponent.runningTimeCompleted": "Runtime completed: ",
  "StatusComponent.plannedRunningTime": "Runtime planned:",
  "StatusComponent.plannedMinRunningTime": "Runtime planned min:",
  "StatusComponent.plannedMaxRunningTime": "Runtime planned max:",
  "StatusComponent.remainingRunningTime": "Runtime remaining:",
  "StatusComponent.remainingMinRunningTime": "Runtime remaining min:",
  "StatusComponent.remainingMaxRunningTime": "Runtime remaining max:",
  "StatusComponent.remainingMinEnergy": "Energy remaining min:",
  "StatusComponent.remainingMaxEnergy": "Energy remaining max:",
  "StatusComponent.energyPlanned": "Energy planned: ",
  "StatusComponent.energyCharged": "Energy charged: ",
  "StatusComponent.energyChargePower": "Current charge power: ",
  "StatusComponent.energyLatestEnd": "Latest end: ",
  "StatusComponent.chargeMode": "Charge mode",
  "StatusComponent.chargeMode.FAST": "Fast",
  "StatusComponent.chargeMode.FAST.description": "The charging process will start immediately with the configured maximum charge power. There is not optimization regarding energy costs or usage of excess energy.",
  "StatusComponent.chargeMode.OPTIMIZED": "Optimized",
  "StatusComponent.chargeMode.OPTIMIZED.description": "The charger will use as much excess energy as possible. To ensure that the target SOC is reached at the specified time, energy from the grid will be used as necessary. Afterwards charging mode changes to \"Excess energy\" automatically.",
  "StatusComponent.chargeMode.EXCESS_ENERGY": "Excess energy",
  "StatusComponent.chargeMode.EXCESS_ENERGY.description": "The charger will only use excess energy which would be fed into the grid otherwise. This charge mode is enabled by default right after the vehicle has been connected to the charger as long as no other charge mode is selected. Therefore the selection of this charge mode is only used to specify the requested state of charge different from the default configured for this vehicle. Using this charge mode a charge cannot be ensured always. If there is no excess energy no charge will occur.",
  "StatusComponent.ev": "Vehicle",
  "StatusComponent.state": "State",
  "StatusComponent.state.VEHICLE_NOT_CONNECTED": "Not connected",
  "StatusComponent.state.VEHICLE_CONNECTED": "Connected",
  "StatusComponent.state.CHARGING": "Charging",
  "StatusComponent.state.CHARGING_COMPLETED": "Charging completed",
  "StatusComponent.state.ERROR": "Error",
  "StatusComponent.soc": "SOC",
  "StatusComponent.socCurrent": "Current ",
  "StatusComponent.socTarget": "Target ",
  "StatusComponent.socUnit": "%",
  "StatusComponent.chargeLatestEndRequested": "until ",
  "StatusComponent.buttonStart": "Start",
  "StatusComponent.buttonCancel": "Cancel",
  "StatusComponent.explanation": "Notes",
  "StatusComponent.explanationNoLight": "The appliance is not switched on because no demand exists.",
  "StatusComponent.explanationStopLight": "The appliance is not switched on although a demand exists because the earliest switch on time has not yet been reached.",
  "StatusComponent.explanationSlowLight": "The appliance can be switched on at any time (again) because demand exists (with blinking light only for excess energy) and the earliest switch on time has been reached.",
  "StatusComponent.explanationGoLight": "The appliance is switched on. A blinking light indicates usage of excess energy.",

  "StatusEditComponent.error.runtime_pattern": "The minimal runtime has to be specified as 'Hours:Minutes'",

  "StatusEvchargerViewComponent.since": "since",
  "StatusEvchargerViewComponent.currently": "currently",

  "StatusEvchargerEditComponent.soc": "SOC",
  "StatusEvchargerEditComponent.error.socCurrent_pattern": "The current SOC has to be a percentage",
  "StatusEvchargerEditComponent.error.socTarget_pattern": "The target SOC has to be a percentage",
  "StatusEvchargerEditComponent.error.chargeEndTime_pattern": "The charge end time has to be specified as 'Hours:Minutes'",

  "SettingsComponent.mqttBroker": "MQTT Broker",
  "SettingsComponent.mqttHost": "Host",
  "SettingsComponent.mqttPort": "Port",
  "SettingsComponent.mqttUsername": "Username",
  "SettingsComponent.mqttPassword": "Password",
  "SettingsComponent.nodeRed": "Node-RED",
  "SettingsComponent.nodeRedDashboardUrl": "Dashboard URL",
  "SettingsComponent.holidays": "Holidays",
  "SettingsComponent.holidaysEnabled": "Enabled",
  "SettingsComponent.holidaysUrl": "Download URL",
  "SettingsComponent.modbus": "Modbus",
  "SettingsComponent.modbusEnabled": "Enabled",
  "SettingsComponent.modbusTcpId": "ID (name)",
  "SettingsComponent.modbusTcpHost": "Host",
  "SettingsComponent.modbusTcpPort": "Port",
  "SettingsComponent.notification.heading": "Notifications",
  "SettingsComponent.notification.command": "Shell script",
  "SettingsComponent.error.mqttBrokerHost_pattern": "The value has to be specified as hostname or an IP address",
  "SettingsComponent.error.mqttBrokerPort_pattern": "The port number has to be valid",
  "SettingsComponent.error.nodeRedDashboardUrl_pattern": "The URL has to be valid",
  "SettingsComponent.error.holidaysUrl_pattern": "The URL has to be valid",
  "SettingsComponent.error.modbusTcpHost_pattern": "The value has to be specified as hostname or an IP address",
  "SettingsComponent.error.modbusTcpPort_pattern": "The port number has to be valid",

  "HttpMethod": "HTTP method",
  "HttpMethod.GET": "GET",
  "HttpMethod.POST": "POST",
  "HttpMethod.PUT": "PUT",
  "HttpMethod.PATCH": "PATCH",
  "HttpMethod.DELETE": "DELETE",

  "dayOfWeek": "Day of week",
  "daysOfWeek_monday": "Monday",
  "daysOfWeek_tuesday": "Tuesday",
  "daysOfWeek_wednesday": "Wednesday",
  "daysOfWeek_thursday": "Thursday",
  "daysOfWeek_friday": "Friday",
  "daysOfWeek_saturday": "Saturday",
  "daysOfWeek_sunday": "Sunday",
  "daysOfWeek_holiday": "Holiday",

  "timeOfDay": "Time",

  "regex.tooltip": "Has to be specified if the value has to be extracted from the response or the response has to match a value",

  "error.input_required": "Input required",
  "error.modbus_not_configured": "Modbus has to be configured in 'Settings' first.",

  "button.new": "Add",
  "button.save": "Save",
  "button.delete": "Delete",
  "dialog.mandatoryfields": "Fields marked with asterik (*) are mandatory fields.",
  "dialog.candeactivate": "Discard changes?",
  "dialog.confirmDelete": "Confirm delete?"
}
